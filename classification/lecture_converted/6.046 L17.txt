Lecture 17
Complexity and NP-completeness
Supplemental reading in CLRS: Chapter 34
As an engineer or computer scientist, it is important not only to be able to solve problems, but also to
know which problems one can expect to solve efﬁciently. In this lecture we will explore the complexity
of various problems, which is a measure of how efﬁciently they can be solved.
17.1 Examples
To begin, we’ll review three problems that we already know how to solve efﬁciently. For each of the
three problems, we will propose a variation which might not be so easy to solve.
•Flow. Given a ﬂow network Gwith integer capacities, we can efﬁciently ﬁnd an integer ﬂow
that is optimal using the Edmonds–Karp algorithm.
•Multi-Commodity Flow. In §13.3, we considered a varation of network ﬂow in which there are
kcommodities which need to simultaneously ﬂow through our network, where we need to send
at least diunits of commodity ifrom source sito sink ti.
•Minimum Cut. Given an undirected weighted graph G, we can efﬁciently ﬁnd a cut ( S,V\S)
of minimum weight.
Exercise 17.1. Design an efﬁcient algorithm to solve the minimum cut problem. (Hint in this
footnote.1)
•Maximum Cut. What if we want to ﬁnd a cut of maximum weight?
•Minimum Spanning Tree. Given an undirected weighted graph GÆ(V,E), we know how
to efﬁciently ﬁnd a spanning tree of minimum weight. A spanning tree of Gis a subgraph
G0Æ(V0,E0)µGsuch that
–G0is connected and contains no cycles
–V0ÆV.
1Hint: Turn Ginto a ﬂow network and ﬁnd a maximum ﬂow. In Theorem 13.7, we saw how to turn a maximum ﬂow
into a minimum cut.•Steiner Tree. What if, instead of requiring V0ÆV, we require V0ÆSfor some given subset
SµV?
Each of these three variations is NP-hard. The typical attitude towards NP-hard problems is
Don’t expect an efﬁcient algorithm for this problem.
However, I prefer the following more optimistic interpretation:
If you ﬁnd an efﬁcient algorithm for this problem, you will get $1 million.2
Unlike the pessimistic interpretation, the above statement is 100% factual. The so-called P vs. NP
problem is one of seven important open research questions for which Clay Mathematics Institute is
offering a $1 million prize.3
17.2 Complexity
So far in the course, we have been ignoring the low-level details of the mathematical framework
underlying our analyses. We have relied on the intuitive notion that our ideal computer is “like a
real-world computer, but with inﬁnite memory”; we have not worried about explicitly deﬁning what
a “step” is. The fact of the matter is that there are many reasonable models of computation which
make these notions explicit. Historically the ﬁrst one was the Turing machine, invented by Alan
Turing, considered by many to be the founding father of computer science. The model we have been
using throughout the course is similar to a Turing machine; the main difference is that a “step” on
our ideal computer closely resembles a processor cycle on a modern computer, whereas the “steps”
of a Turing machine involve sequentially reading and writing to the so-called tape which represents
its memory. For this lecture, you won’t have to go to the trouble of working with a particular model
of computation in full detail; but it is worth noting that such details are important in theoretical
computer science and should not be regarded as a triviality.
In what follows, we will deﬁne the complexity classes P and NP. Before doing so, we will need a
couple more deﬁnitions:
Deﬁnition. Adecision problem is a computation problem to which the answer is either “yes” or
“no.” In mathematical language, we can think of a decision problem as a function whose domain is
the set of possible input strings4and whose range is {0,1} (with 0 meaning “no” and 1 meaning “yes”).
Deﬁnition. Acomplexity class is simply a set of decision problems.
Most of the problems we have considered so far in the course are not decision problems but rather
search problems—they ask not just whether a solution exists, but also what the solution is. Given
a search problem, we can derive decision problems which ask yes-or-no questions about the solution;
for example, we might ask:
2I should warn you though, most computer scientists believe that it is not possible to ﬁnd one. (In other words, most
computer scientists believe that P 6ÆNP.)
3One of the questions has already been solved, so currently there are six prizes remaining.
4Strings over what alphabet? A typical choice is {0,1} (i.e., binary); another possible choice is the ASCII alphabet. The
main reason the choice of alphabet matters is that it determines what “an input of size n” is. The number 255 has size 8
in binary, size 1 in ASCII, and size 255 in unary. An algorithm whose running time is linear with respect to a unary input
would be exponential with respect to a binary input.
Lec 17 – pg. 2 of 7Problem 17.1. Given a graph Gand an integer k, is there a spanning tree of size less than k?
For most real-world applications, search problems are much more important than decision prob-
lems. So why do we restrict our attention to decision problems when deﬁning complexity classes?
Here are a few reasons:
• The answer to a decision problem is simple.
• The answer to a decision problem is unique. (A search problem might have multiple correct
answers, e.g., a given graph might have multiple minimum spanning trees.)
• A decision problem which asks about the answer to a search problem is at most as difﬁcult
as the search problem itself. For example, if we can ﬁnd a minimum spanning tree efﬁciently,
then we can certainly also solve Problem 17.1 efﬁciently.
17.2.1 P and NP
The existence of many different models of computation is part of the reason for the following deﬁni-
tion:
Deﬁnition. “Efﬁcient” means “polynomial-time.” An algorithm is polynomial-time if there exists
a constant rsuch that the running time on an input of size nisO(nr). The set of all decision problems
which have polynomial-time solutions is called P.
Polynomial time is the shortest class of running times that is invariant across the vast majority
of reasonable, mainstream models of computation. To see that shorter running times need not be
invariant, consider the following program:
1Read the ﬁrst bit of memory
2Read the nth bit of memory
In our model of computation, which has random access to memory, this would take constant time.
However, in a model of computation with only serial access to memory (such as a Turing machine),
this would take linear time. It is true, though, that any polynomial-time program in our model is
also polynomial-time on a Turing machine, and vice versa.
Search problems have the property that, once a solution is found, it can be veriﬁed quickly. This
veriﬁability is the motivation for the complexity class NP.
Deﬁnition. A decision problem Pis in NPif there exists a polynomial-time algorithm A(x,y) such
that, for every input xto the problem P,
P(x)Æ1() there exists some ysuch that A(x,y)Æ1.
The string yis called a witness orcertiﬁcate; the algorithm Ais called a veriﬁer or anondeter-
ministic algorithm.5
For example, in Problem 17.1, the witness ycould be the spanning tree itself—we can certainly
verify in polynomial time that a given object yis a spanning tree of size less than k.
5The abbrevation NP stands for “nondeterministic polynomial-time.” The reason for this name is as follows. Imagine
receiving x(the input to the problem P) but leaving the choice of yunspeciﬁed. The result is a set of possible running
times of A, one for each choice of y. The problem Pis in NP if and only if at least one of these possible running times is
bounded by a polynomial p(jxj)in the size of x. (The choice of ycan depend on x, but pcannot depend on x.)
Lec 17 – pg. 3 of 7BA
Figure 17.1. A Cook reduction of AtoBis a program that would run in polynomial time on an oracle machine—that is,
a Turing machine equipped with an oracle for B. If some day we ﬁnd an efﬁcient algorithm for B, then we can create an
efﬁcient algorithm for Aby replacing the oracle with a subroutine.
Proposition 17.2. PµNP.
Proof. Given a decision problem P, view Pas a function whose domain is the set of strings and whose
range is {0,1}. If Pcan be computed in polynomial time, then we can just take A(x,y)ÆP(x). In this
case, the veriﬁer just re-solves the entire problem.
The converse to the above proposition is a famous open problem:
Problem 17.3 (P vs. NP). Is it true that P ÆNP?
The vast majority of computer scientists believe that P 6ÆNP, and so the P vs. NP problem is
sometimes called the P 6ÆNP problem. If it were true that P ÆNP, then lots of problems that seem
hard would actually be easy: one such example is the algorithm search problem described in §17.3.
17.2.2 Polynomial-time reductions
It is possible to know that one problem is “at least as hard” as another without knowing exactly how
hard each problem is. If problem Acan be polynomial-time reduced to problem B, then it stands
to reason Bis at least as hard as A. There are two different notions of polynomial-time reduction,
which we now lay out.
Deﬁnition. We say that the decision problem AisKarp-reducible to the decision problem Bif
there exists a polynomial-time computable function fsuch that, for every input x,
A(x)Æ1() B(f(x))Æ1.
Deﬁnition. Problem AisCook-reducible to problem Bif there exists an algorithm which, given
an oracle6forB, solves Ain polynomial time. (See Figure 17.1.)
Note that a Karp reduction is also a Cook reduction, but not vice versa. Historically, Karp reduc-
tions and Cook reductions correspond to different traditions.
Deﬁnition. A problem is NP-hard if every problem in NP can be Cook-reduced to it.
6Anoracle forBis a magical black-box which solves any instance of problem Bin one step. A Cook reduction is a
program which is allowed to do any of the normal things a computer program does, and is also allowed to query the oracle.
Lec 17 – pg. 4 of 7Problems with
efﬁcient solution
(or equivalently,
NP-complete
problems)Every decision
problem is
NP-hardProblems with
efﬁcient solutionNP-hard NP-complete
PÆNP P6ÆNP
Figure 17.2. Left: If P ÆNP, then every decision problem is NP-hard (why?). Right: If P 6ÆNP.
Deﬁnition. A problem is NP-complete if it is both NP-hard and in NP.
Using the notion of NP-completeness, we can make an analogy between NP-hardness and big-O
notation:
O(f(n))  in NP
on the order of at most f (n) at most as hard as an NP-complete problem
£(f(n))  NP-complete
tightly on the order of f (n) exactly as hard as any other NP-complete problem
­(f(n))  NP-hard
on the order of at least f (n) at least as hard as an NP-complete problem
Showing that a given problem is in NP is relatively straightforward (or at least, it is clear what
the proof should look like): one must give a polynomial-time veriﬁer. By contrast, it is much less clear
how one might show that a given problem is NP-hard. One strategy is to reduce another NP-hard
problem to it. But this strategy only works if one already knows certain problems to be NP-hard; it
could not have been used as the ﬁrst ever proof that a problem was NP-hard. That ﬁrst proof was
accomplished by Cook in 1971:
Theorem 17.4 (Cook’s Theorem). 3SAT isNP-complete.
Problem 17.5 (3SAT). Given a set of atomic statements x1,...,xn, aliteral is either an atom xior
its negation :xi. Aclause is the disjunction (“or”) of a ﬁnite set of literals. The 3SAT problem asks,
given a propositional formula '(x1,...,xn) which is the “and” of ﬁnitely many clauses of length 3, does
there exist an assignment of either T RUE or F ALSE to each xiwhich makes '(x1,...,xn) evaluate to
TRUE?
For example, one instance of 3SAT asks whether there exists an assignment of x1,...,x4which
makes the proposition
(x1_x2_:x3)|{z}
clause^(:x1_x3_x4)|{z}
clause^(:x1_:x2_:x3)|{z }
clause^(x1_x3_:x4)|{z}
clause.
evaluate to T RUE. The answer to this instance happens to be “yes,” as shown by the assignment
x27!TRUE,x1,x3,x47!FALSE .
Lec 17 – pg. 5 of 717.3 Example: Algorithm Search
In this section, we solve an algorithmic problem whose output is itself an algorithm:
Problem 17.6. Given an algorithmic problem Pand a function T(n), ﬁnd an algorithm which runs
in time at most T(n), if such an algorithm exists. Output not just a description of the algorithm, but
also a proof of correctness and running time analysis.
Proposition 17.7. There exists a “meta-algorithm” which solves Problem 17.6 (but runs forever if no
algorithm exists). If PÆNP, then the running time of this meta-algorithm is polynomial in the size of
the shortest possible output.
The formats of both the input and the output of this algorithm deserve some explanation. By “an
algorithmic problem,” we mean a mathematical description of the relationship between the input
and the output. For example, we could express the notion of “a ﬂow with magnitude at least k” in
symbols as
8
>>>>>><
>>>>>>:8u,v2V0·f(u,v)·c(u,v)
8u2V\{s,t}X
v2Vf(u,v)ÆX
v2Vf(v,u)
X
v2Vf(s,v)¡X
v2Vf(v,s)¸k9
>>>>>>=
>>>>>>;.
In the case of a decision problem, this would be more along the lines of
(
1 if there exists fsatisfying the above
0 otherwise.
Regarding the output of our meta-algorithm, we need a format for “a description of the algo-
rithm.” One possibility is a text ﬁle containing the source code of an implementation in a particular
programming language. Next, we need a format for “a proof of correctness and running time analy-
sis.” For this we appeal to a machine-checkable proof language of the sort used by theorem-checking
software. One such software suite is Coq.7If you’ve never seen Coq before, I suggest you check it
out!
The key to the proof of Proposition 17.7 is to consider the following problem:
Problem 17.8. Given an algorithmic problem P, a function T(n) and an integer k, does there exist
a solution to Problem 17.6 in which the output has length at most k?
Problem 17.8 is in NP, so if P ÆNP then there exists a polynomial-time algorithm for it.
Proof of Proposition 17.7. Consider the following search problem:
Problem 17.9. Given an algorithmic problem P, a function T(n), an integer k, and a preﬁx string s,
does there exist a solution to Problem 17.8 in which the output starts with s?
7http://coq.inria.fr/
Lec 17 – pg. 6 of 7Problem 17.9 is in NP, so if P ÆNP then there exists a polynomial-time algorithm for it. Thus, if
we let jPjdenote the length of the description of P,jTjthe length of the deﬁnition of the function
T, and jsjthe length of s, then there exist constants a,b,c,dsuch that Problem 17.9 has a solution
A(P,T,k,s) which runs in time
O³¯¯P¯¯a¯¯T¯¯bkc¯¯s¯¯d´
.
We can use this algorithm to solve Problem 17.8 by probing longer and longer preﬁxes s. For example,
supposing we use the 26-letter alphabet A, . . . , Zfor inputs, we would proceed as follows:
• Run A(P,T,k,A). If the answer is 0, then run A(P,T,k,B). Proceed in this way until you ﬁnd a
preﬁx which returns 1. If all 26 letters return 0, then the answer to Problem 17.8 is “no.”
• Otherwise, let’s say for the sake of a concrete example that A(P,T,k,F)Æ1. Then, run
A(P,T,k,FA), A(P,T,k,FB), etc.,
until you ﬁnd a two-letter preﬁx that returns 1.
• Proceeding in this way, the preﬁx swill eventually become the answer to Problem 17.8.
The above procedure solves Problem 17.8. Because the length of sranges from 1 to at most k, the
running time is
O³
26¯¯P¯¯a¯¯T¯¯bkc1dÅ26¯¯P¯¯a¯¯T¯¯bkc2dÅ¢¢¢Å 26¯¯P¯¯a¯¯T¯¯bkckd´
ÆO³¯¯P¯¯a¯¯T¯¯bkc³
1dÅ2dÅ¢¢¢Å kd´´
ÆO³¯¯P¯¯a¯¯T¯¯bkckdÅ1´
ÆO³¯¯P¯¯a¯¯T¯¯bkcÅdÅ1´
.
Thus, we have done more than just show that Problem 17.8 is in P. We have shown that, for some
constants ®,¯,°, there exists a solution to Problem 17.8 which runs in time O¡
jPj®jTj¯k°¢
and also
returns the full algorithm-and-proofs, not just 0 or 1.
To conclude the proof, our meta-algorithm is to run the above procedure for kÆ1,2,3,.... If the
shortest possible algorithm-and-proofs has length `, then the running time of the meta-algorithm is
O³¯¯P¯¯®¯¯T¯¯¯1°Å¯¯P¯¯®¯¯T¯¯¯2°Å¢¢¢Å¯¯P¯¯®¯¯T¯¯¯`°´
ÆO³¯¯P¯¯®¯¯T¯¯¯`°Å1´
.
Lec 17 – pg. 7 of 7MIT OpenCourseWare
http://ocw.mit.edu
6.046J / 18.410J Design and Analysis of Algorithms
Spring 2012 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .